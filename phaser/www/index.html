<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />

  <!-- Mobile devices -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, user-scalable=no" />

  <title>Phaser</title>
</head>

<body style="background:#0f1418;margin:0px;">
  <!-- Game ------------------------------------------------------------------->
  <div id="canvas-wrapper" style="width:100%;text-align:center;"></div>
  
  <!-- Debug -->
  <script src="js/frima.js"></script>
  <script src="js/phaser.js"></script>
  <script src="js/phaser-plugin-isometric.js"></script>
  
  <!-- Game -->
  <script>
    var game = new Phaser.Game(800, 400, Phaser.AUTO, 'canvas-wrapper', null, true, false);

    var BasicGame = function (game) { };

    BasicGame.Boot = function (game) { };

    var cameraPos, cursorPos, isoGroup, player;

    var addPositions = {x:40, y:0};
    var clickAction = 'add';

    BasicGame.Boot.prototype =
    {
        preload: function () {
            game.load.image('cube', 'assets/images/cube.png');

            game.time.advancedTiming = true;

            // Add and enable the plug-in.
            game.plugins.add(new Phaser.Plugin.Isometric(game));

            // In order to have the camera move, we need to increase the size of our world bounds.
            game.world.setBounds(0, 0, 2048, 1024);

            // Start the IsoArcade physics system.
            game.physics.startSystem(Phaser.Plugin.Isometric.ISOARCADE);

            // This is used to set a game canvas-based offset for the 0, 0, 0 isometric coordinate - by default
            // this point would be at screen coordinates 0, 0 (top left) which is usually undesirable.
            // When using camera following, it's best to keep the Y anchor set to 0, which will let the camera
            // cover the full size of your world bounds.
            game.iso.anchor.setTo(0.5, 0);
        },
        create: function () {
            // Create a group for our tiles, so we can use Group.sort
            isoGroup = game.add.group();

            // Set the global gravity for IsoArcade.
            game.physics.isoArcade.gravity.setTo(0, 0, -500);

            // Let's make a load of cubes on a grid, but do it back-to-front so they get added out of order.
            var cube;
            for (var xx = 400; xx > 0; xx -= 40) {
                for (var yy = 400; yy > 0; yy -= 40) {
                    // Create a cube using the new game.add.isoSprite factory method at the specified position.
                    // The last parameter is the group you want to add it to (just like game.add.sprite)
                    cube = game.add.isoSprite(xx, yy, 0, 'cube', 0, isoGroup);
                    cube.anchor.set(0.5);

                    // Enable the physics body on this cube.
                    game.physics.isoArcade.enable(cube);

                    // Collide with the world bounds so it doesn't go falling forever or fly off the screen!
                    cube.body.collideWorldBounds = true;

                    // Add a full bounce on the x and y axes, and a bit on the z axis. 
                    cube.body.bounce.set(0, 0, 0);

                    // Add some X and Y drag to make cubes slow down after being pushed.
                    cube.body.drag.set(100, 100, 0);
                }
            }
            /*
            for (var xx = 400; xx > 0; xx -= 140) {
                for (var yy = 400; yy > 0; yy -= 140) {
                    // Create a cube using the new game.add.isoSprite factory method at the specified position.
                    // The last parameter is the group you want to add it to (just like game.add.sprite)
                    cube = game.add.isoSprite(xx, yy, 100, 'cube', 0, isoGroup);
                    cube.anchor.set(0.5);

                    // Enable the physics body on this cube.
                    game.physics.isoArcade.enable(cube);

                    // Collide with the world bounds so it doesn't go falling forever or fly off the screen!
                    cube.body.collideWorldBounds = true;

                    // Add a full bounce on the x and y axes, and a bit on the z axis. 
                    cube.body.bounce.set(1, 1, 0.2);

                    // Add some X and Y drag to make cubes slow down after being pushed.
                    cube.body.drag.set(100, 100, 0);
                }
            }
            */

            cameraPos = new Phaser.Plugin.Isometric.Point3();
            cursorPos = new Phaser.Plugin.Isometric.Point3();

            // Create another cube as our 'player', and set it up just like the cubes above.
            player = game.add.isoSprite(128, 128, 50, 'cube', 0, isoGroup);
            player.tint = 0x86bfda;
            player.anchor.set(0.5);
            game.physics.isoArcade.enable(player);
            player.body.collideWorldBounds = true;

            // Set up our controls.
            this.cursors = game.input.keyboard.createCursorKeys();

            this.game.input.keyboard.addKeyCapture([
                Phaser.Keyboard.LEFT,
                Phaser.Keyboard.RIGHT,
                Phaser.Keyboard.UP,
                Phaser.Keyboard.DOWN,
                Phaser.Keyboard.SPACEBAR
            ]);

            var space = game.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR);

            space.onDown.add(function () {
                player.body.velocity.z = 300;
            }, this);

            // Make the camera follow the player.
            game.camera.follow(player);

            var event = document.createEvent("Event");
            event.initEvent('addToDOM',true,true);
            document.dispatchEvent(event);

            var mouse = new Phaser.Mouse(game);
            mouse.mouseDownCallback = function() { console.log('sauce'); };

            var key1Action = function() {
                clickAction = 'add';
                player.tint = 0x86bfda;
            };
            key1 = game.input.keyboard.addKey(Phaser.Keyboard.ONE);
            key1.onDown.add(key1Action, this);
            var key2Action = function() {
                clickAction = 'remove';
                player.tint = 0x86da88;
            };
            key2 = game.input.keyboard.addKey(Phaser.Keyboard.TWO);
            key2.onDown.add(key2Action, this);

            var clickActions = function() {
                if(clickAction == 'add') {
                    var xPosition = (Math.floor(player.isoPosition.x / 40) * 40);
                    var yPosition = (Math.floor(player.isoPosition.y / 40) * 40);
                    var zPosition = 0;
                    {

                        if(addPositions.x == 0) {
                            var xPosition = xPosition + 40;
                        }
                        if(addPositions.x > 0) {
                            var xPosition = xPosition + 80;
                        }
                        else{
                            var xPosition = xPosition - 40;
                        }
                        if(addPositions.y == 0) {
                            var yPosition = yPosition + 40;
                        }
                        if(addPositions.y > 0) {
                            var yPosition = yPosition + 80;
                        }
                        else{
                            var yPosition = yPosition - 40;
                        }
                        isoGroup.forEach(function (tile) {
                            console.log(tile);
                            if(tile.isoPosition.x == xPosition && tile.isoPosition.y == yPosition && tile.isoPosition.z >= zPosition) {
                                zPosition = tile.isoPosition.z + 80;
                            }
                        });
                    }
                    cube = game.add.isoSprite(xPosition, yPosition, zPosition, 'cube', 0, isoGroup);
                    cube.anchor.set(0.5);


                    // Enable the physics body on this cube.
                    game.physics.isoArcade.enable(cube);

                    // Collide with the world bounds so it doesn't go falling forever or fly off the screen!
                    cube.body.collideWorldBounds = true;

                    // Add a full bounce on the x and y axes, and a bit on the z axis. 
                    cube.body.bounce.set(0, 0, 0);

                    // Add some X and Y drag to make cubes slow down after being pushed.
                    cube.body.drag.set(100, 100, 0);
                }
                else if(clickAction == 'remove') {
                    for(var i = 0; i < isoGroup.children.length; i++) {
                        var child = isoGroup.children[i];
                        var isoPosition = child.isoPosition;
                        console.log(isoPosition.x, player.isoPosition.x, isoPosition.y, player.isoPosition.y);
                        if(
                            (isoPosition.x - orientation.x > player.isoPosition.x)
                            //(isoPosition.y - orientation.y > player.isoPosition.y && isoPosition.y - orientation.y < player.isoPosition.y + 40)
                          ) {
                            isoGroup.remove(child);
                        }
                    }
                }
            }

            this.game.input.onDown.add(clickActions);
        },
        update: function () {
            // Move the player at this speed.
            var speed = 100;

            if (this.cursors.up.isDown) {
                addPositions = {x:0,y:-40};
                player.body.velocity.y = -speed;
            }
            else if (this.cursors.down.isDown) {
                player.body.velocity.y = speed;
                addPositions = {x:0,y:40};
            }
            else {
                player.body.velocity.y = 0;
            }

            if (this.cursors.left.isDown) {
                player.body.velocity.x = -speed;
                addPositions = {x:-40,y:0};
            }
            else if (this.cursors.right.isDown) {
                player.body.velocity.x = speed;
                addPositions = {x:40,y:0};
            }
            else {
                player.body.velocity.x = 0;
            }

            game.iso.unproject(game.input.activePointer.position, cursorPos);
            game.iso.unproject(game.camera.position, cameraPos);
            //console.log('pointer', game.input.activePointer.position.x, game.input.activePointer.position.y, 'cursorPos', cursorPos.x, cursorPos.y, 'camera', game.camera.position.x, game.camera.position.y, 'cameraPos', cameraPos.x, cameraPos.y);
            /*
            isoGroup.forEach(function (tile) {
                var inBounds = tile.isoBounds.containsXY(cameraPos.x, cameraPos.y);
                // If it does, do a little animation and tint change.
                if (!tile.selected && inBounds) {
                    tile.selected = true;
                    tile.tint = 0x86bfda;
                }
                // If not, revert back to how it was.
                else if (tile.selected && !inBounds) {
                    tile.selected = false;
                    tile.tint = 0xffffff;
                }
            });
            */

            // Our collision and sorting code again.
            game.physics.isoArcade.collide(isoGroup);
            game.iso.topologicalSort(isoGroup);
        },
        render: function () {
            game.debug.text("Move with cursors, jump with space!", 2, 36, "#ffffff");
            game.debug.text(game.time.fps || '--', 2, 14, "#a7aebe");
        }
    };

    game.state.add('Boot', BasicGame.Boot);
    game.state.start('Boot');
  </script>
</body>

</html>
